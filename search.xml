<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AFL源码分析【1】：afl-gcc</title>
    <url>/2025/02/10/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%901%E3%80%91%EF%BC%9Aafl-gcc/</url>
    <content><![CDATA[<p>AFL主要的代码在afl_fuzz当中，有几个独立功能代码是分开的，其中<code>llvm_mode</code>和<code>qumu_mode</code>代码差不多，是两种模式的插桩代码，我们主要要分析的代码在<code>afl_fuzz.c</code>中。<br>在分析源代码之前，我们需要大致理解一下AFL源码的结构：</p>
<ul>
<li>插桩代码：<br>  <code>afl-as.h</code>,<code>afl-as.c</code>,<code>afl-gcc.c</code>：一般插桩模式，是针对源码进行插桩<br>  <code>llvm_mode</code>：llvm插桩模式，针对源码进行插桩，编译器使用clang<br>  <code>qemu_mode</code>：qemu插桩模式，针对二进制文件进行插桩</li>
<li>fuzz模块：<br>  <code>afl-fuzz.c</code>：实现fuzz的核心代码，AFL的主体。</li>
<li>其他辅助模块：<br>  <code>afl-analyze</code>：对测试用例进行分析，通过分析给定的用例，确定是否可以发现用例中有意义的字段。<br>  <code>afl-plot</code>：生成测试任务的状态图<br>  <code>afl-tmin</code>：对测试用例进行最小化<br>  <code>afl-cmin</code>：对语料库进行精简操作<br>  <code>afl-showmap</code>：对测试用例进行路径反馈<br>  <code>afl-whatsup</code>：对并行fuzzing进行结果统计<br>  <code>afl-gotcpu</code>：查看当前CPU状态</li>
</ul>
<h2 id="afl-gcc-c"><a href="#afl-gcc-c" class="headerlink" title="afl-gcc.c"></a>afl-gcc.c</h2><p><code>afl-gcc</code>是对GCC或clang的封装，常规的用法是：在构建应用程序的时候，使用<code>./configure</code>时通过<code>cc</code>将路径传递给<code>afl-gcc</code>或者<code>afl-clang</code>，或者我们在需要插装的时候，直接使用<code>afl-as</code>进行编译。<br><code>afl-gcc</code>实际上的作用就只是作为中间人，寻找<code>afl-as</code>，注意在对编译命令操作的时候，有一个很重要的<code>-B</code>选项，告知编&#x3D;汇编器应该在哪个路径下。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="&lt;1&gt;.变量"></a>&lt;1&gt;.变量</h3><p>首先我们来看一下用到的变量：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AFL as的路径</span></span><br><span class="line"><span class="type">static</span> u8*  as_path;                <span class="comment">/* Path to the AFL &#x27;as&#x27; wrapper      */</span></span><br><span class="line"><span class="comment">//真正传递给CC的参数</span></span><br><span class="line"><span class="type">static</span> u8** cc_params;              <span class="comment">/* Parameters passed to the real CC  */</span></span><br><span class="line"><span class="comment">//参数数量，包括argv0</span></span><br><span class="line"><span class="type">static</span> u32  cc_par_cnt = <span class="number">1</span>;         <span class="comment">/* Param count, including argv0      */</span></span><br><span class="line"><span class="comment">//静默模式/是否使用afl-clang*</span></span><br><span class="line"><span class="type">static</span> u8   be_quiet,               <span class="comment">/* Quiet mode                        */</span></span><br><span class="line">            clang_mode;             <span class="comment">/* Invoked as afl-clang*?            */</span></span><br></pre></td></tr></table></figure></div>
<h3 id="主函数逻辑分析"><a href="#主函数逻辑分析" class="headerlink" title="&lt;2&gt;.主函数逻辑分析"></a>&lt;2&gt;.主函数逻辑分析</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line">         </span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line">    <span class="comment">/*这是afl-fuzz的辅助应用程序，它可以作为gcc或clang的替代品，让您可以使用所需的运行时</span></span><br><span class="line"><span class="comment">      工具重新编译第三方代码。常见的使用模式时以下之一/</span></span><br><span class="line"><span class="comment">      你可以通过AFL_CC,AFL_CXX和AFL_AS指定自定义下一阶段工具链。</span></span><br><span class="line"><span class="comment">      设置AFL_HARDEN可以在编译的代码中启用强化优化*/</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//寻找afl-gcc的位置</span></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; cc_par_cnt;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,cc_params[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//这里为了能够更详细地看到传递的命令</span></span><br><span class="line">  </span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到在main函数中首先获取环境变量<code>AFL-QUIET</code>的值，然后输出了一段程序信息，随后进行了三次函数调用，分别为<code>find_as</code>,<code>edit_params</code>和<code>execvp</code>，我们来详细分析一下这三个函数：</p>
<h3 id="find-as函数分析"><a href="#find-as函数分析" class="headerlink" title="&lt;3&gt;.find_as函数分析"></a>&lt;3&gt;.find_as函数分析</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">find_as</span><span class="params">(u8* argv0)</span> &#123;</span><br><span class="line">  u8 *afl_path = getenv(<span class="string">&quot;AFL_PATH&quot;</span>);</span><br><span class="line">  u8 *slash, *tmp;</span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/as&quot;</span>, afl_path);</span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123; <span class="comment">//测试AFL_PATH路径是否可执行</span></span><br><span class="line">      as_path = afl_path;</span><br><span class="line">      ck_free(tmp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ck_free(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>);<span class="comment">//检索命令行参数中有没有&#x27;/&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (slash) &#123;</span><br><span class="line">    u8 *dir;</span><br><span class="line">    *slash = <span class="number">0</span>;</span><br><span class="line">    dir = ck_strdup(argv0);</span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/afl-as&quot;</span>, dir);</span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;<span class="comment">//检测argv[0]/afl-as是否可执行</span></span><br><span class="line">      as_path = dir;</span><br><span class="line">      ck_free(tmp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ck_free(tmp);</span><br><span class="line">    ck_free(dir);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!access(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123;</span><br><span class="line">    <span class="comment">//如果上述两种都没有，则检测AFL_PATH/as是否可执行</span></span><br><span class="line">    as_path = AFL_PATH;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  FATAL(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在<code>find_as</code>函数中，分别按序从<code>AFL_PATH</code>、<code>argv[0]</code>和<code>AFL_PATH/as</code>中寻找了as，并将找到的位置赋值给变量<code>as_path</code>。</p>
<h3 id="edit-params函数分析"><a href="#edit-params函数分析" class="headerlink" title="&lt;4&gt;.edit_params函数分析"></a>&lt;4&gt;.edit_params函数分析</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">edit_params</span><span class="params">(u32 argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  u8 fortify_set = <span class="number">0</span>, asan_set = <span class="number">0</span>;</span><br><span class="line">  u8 *name;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">  u8 m32_set = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  cc_params = ck_alloc((argc + <span class="number">128</span>) * <span class="keyword">sizeof</span>(u8*));</span><br><span class="line">  name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;afl-clang&quot;</span>, <span class="number">9</span>)) &#123;<span class="comment">//如果在命令行参数中匹配到/clang</span></span><br><span class="line">    clang_mode = <span class="number">1</span>;</span><br><span class="line">    setenv(CLANG_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-clang++&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;clang++&quot;</span>; <span class="comment">//使用AFL_CXX或者clang++</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;clang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* With GCJ and Eclipse installed, you can actually compile Java! The</span></span><br><span class="line"><span class="comment">       instrumentation will work (amazingly). Alas, unhandled exceptions do</span></span><br><span class="line"><span class="comment">       not call abort(), so afl-fuzz would need to be modified to equate</span></span><br><span class="line"><span class="comment">       non-zero exit codes with crash conditions when working with Java</span></span><br><span class="line"><span class="comment">       binaries. Meh. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!cc_params[<span class="number">0</span>]) &#123;</span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;On Apple systems, &#x27;gcc&#x27; is usually just a wrapper for clang. Please use the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    &#x27;afl-clang&#x27; utility instead of &#x27;afl-gcc&#x27;. If you really have GCC installed,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    set AFL_CC or AFL_CXX to specify the correct path to that compiler.\n&quot;</span>);</span><br><span class="line">      FATAL(<span class="string">&quot;AFL_CC or AFL_CXX required on MacOS X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;g++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcj&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcc&quot;</span>; <span class="comment">//确定调用那个编译器</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">    u8* cur = *(++argv);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(cur, <span class="string">&quot;-B&quot;</span>, <span class="number">2</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!be_quiet) WARNF(<span class="string">&quot;-B is already set, overriding&quot;</span>); <span class="comment">//找-B参数</span></span><br><span class="line">      <span class="keyword">if</span> (!cur[<span class="number">2</span>] &amp;&amp; argc &gt; <span class="number">1</span>) &#123; argc--; argv++; &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-integrated-as&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-pipe&quot;</span>)) <span class="keyword">continue</span>; <span class="comment">//忽略-interated-a和-pipe</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) m32_set = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  cc_params[cc_parr_cnt++] = <span class="string">&quot;-B&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = as_path;</span><br><span class="line">  <span class="keyword">if</span> (clang_mode)</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-no-integrated-as&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>)) &#123;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fstack-protector-all&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fortify_set)</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-D_FORTIFY_SOURCE=2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asan_set) &#123; <span class="comment">//添加ASAN路径</span></span><br><span class="line">    <span class="comment">/* Pass this on to afl-as to adjust map density. */</span></span><br><span class="line">    setenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;MSAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=memory&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="comment">/* On 64-bit FreeBSD systems, clang -g -m32 is broken, but -m32 itself</span></span><br><span class="line"><span class="comment">       works OK. This has nothing to do with us, but let&#x27;s avoid triggering</span></span><br><span class="line"><span class="comment">       that bug. */</span></span><br><span class="line">    <span class="keyword">if</span> (!clang_mode || !m32_set)</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>;</span><br><span class="line">    <span class="comment">/* Two indicators that you&#x27;re building for fuzzing; one of them is</span></span><br><span class="line"><span class="comment">       AFL-specific, the other is shared with libfuzzer. */</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strstr&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasestr&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cc_params[cc_par_cnt] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们可以看到，在<code>edit_params</code>函数中，主要做的就是检索命令行参数，然后寻找一些路径，最后拼接出新的命令。<br>而在最后，<code>execvp(cc_params[0], (char**)cc_params);</code>就是使用新命令，调用编译器。</p>
]]></content>
      <categories>
        <category>AFL源码分析</category>
      </categories>
      <tags>
        <tag>AFL源码分析</tag>
        <tag>二进制漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年终总结</title>
    <url>/2025/01/22/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>时间过得真快，一转眼，2024已经过去了，大三已经一半走过了，晃悠晃悠，就可以开始准备秋招了……<br>回想2024，一整年都在摆。要不是我翻了一下以前写的博客，还真不知道自己这一年都干了些什么。</p>
<h2 id="2024总结"><a href="#2024总结" class="headerlink" title="2024总结"></a>2024总结</h2><p>前半年，过完年二三月份开始学习了漏洞，先知社区发表了几篇博客，关于Windows下的几种保护机制。<br>三四月份，应该在摆烂。<br>五六七八月份，安全研究员实习，分析APT样本，产出分析报告，yara、snotr、sgi规则，编写控制端。<br>七八九十十一月，emmmm……说实话谈恋爱去了。<br>十二月至今，安全研究员实习，还是分析APT样本……</p>
<h1 id="关于2024的思考"><a href="#关于2024的思考" class="headerlink" title="关于2024的思考"></a>关于2024的思考</h1><p>我是2023年开始深入计算机学习，相较于2023年今年动力减少了很多，自驱力还是不够，今年真的是彻彻底底摆了一年，现在回想起来，我真该*啊，浪费了这么多时间，我要是把这些时间都花在学习上，也许就称为大佬了……哎，不过既然过去了也就不后悔，希望引以为戒，2025继续努力，更上一层楼！</p>
<h1 id="2025展望"><a href="#2025展望" class="headerlink" title="2025展望"></a>2025展望</h1><p>前半年：</p>
<ol>
<li>继续深入二进制漏洞挖掘</li>
<li>学习IOT安全</li>
<li>争取拿到自己的cve<br>至于后半年，应该准备秋招了，到时候肯定会发现自己的很多短板，到时候去补足就可以了。</li>
</ol>
]]></content>
      <categories>
        <category>总结规划</category>
      </categories>
      <tags>
        <tag>总结规划</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL源码分析【2】：afl-as</title>
    <url>/2025/02/10/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%902%E3%80%91%EF%BC%9Aafl-as/</url>
    <content><![CDATA[<p>在分析编译的源码的时候，我们发现调用的是<code>afl-as</code>，并不是原生gcc，而在<code>afl-as.c</code>中，就是完成了插桩功能：</p>
<h4 id="afl-as-h"><a href="#afl-as-h" class="headerlink" title="&lt;1&gt;.afl-as.h"></a>&lt;1&gt;.afl-as.h</h4><p>首先我们来看一下<code>afl-as.h</code>，发现其中都是一些汇编代码，猜测是用于插装或者路径信息反馈的函数，我们分析到的时候仔细看。</p>
<h4 id="afl-as-c"><a href="#afl-as-c" class="headerlink" title="&lt;2&gt;.afl-as.c"></a>&lt;2&gt;.afl-as.c</h4><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><p>首先我们来看看main函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);</span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</span><br><span class="line">  srndom(rand_seed);<span class="comment">//随机数获取方法</span></span><br><span class="line">  edit_params(argc, argv);  <span class="comment">/*编辑传递给as的参数*/</span></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))</span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line">  <span class="comment">/*在使用 ASAN 编译时，我们没有特别优雅的方式跳过与 ASAN 相关的分支。但我们可以通过概率方式来弥补这一点……*/</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;</span><br><span class="line">    inst_ratio /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();</span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插装完成，请查看中间文件：%s&quot;</span>,)</span><br><span class="line">    <span class="comment">//_sleep(10000)</span></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);</span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);</span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到在main函数中，主要调用了<code>edit_params</code>函数进行调整参数，调用了<code>add_instrumentation()</code>函数进行插桩。<br>我们来仔细看看这俩函数：</p>
<h5 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h5><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Examine and modify parameters to pass to &#x27;as&#x27;. Note that the file name</span></span><br><span class="line"><span class="comment">   is always the last parameter passed by GCC, so we exploit this property</span></span><br><span class="line"><span class="comment">   to keep the code simple. */</span></span><br><span class="line"><span class="comment">/*检查并修改传递给 as 的参数。请注意，文件名总是 GCC 传递的最后一个参数，因此我们利用这一特性来简化代码。*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">edit_params</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  u8 *tmp_dir = getenv(<span class="string">&quot;TMPDIR&quot;</span>), *afl_as = getenv(<span class="string">&quot;AFL_AS&quot;</span>); <span class="comment">//获取缓存文件夹路径和AFL_AS路径</span></span><br><span class="line">  u32 i;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  u8 use_clang_as = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* On MacOS X, the Xcode cctool &#x27;as&#x27; driver is a bit stale and does not work</span></span><br><span class="line"><span class="comment">     with the code generated by newer versions of clang that are hand-built</span></span><br><span class="line"><span class="comment">     by the user. See the thread here: http://goo.gl/HBWDtn.</span></span><br><span class="line"><span class="comment">     To work around this, when using clang and running without AFL_AS</span></span><br><span class="line"><span class="comment">     specified, we will actually call &#x27;clang -c&#x27; instead of &#x27;as -q&#x27; to</span></span><br><span class="line"><span class="comment">     compile the assembly file.</span></span><br><span class="line"><span class="comment">     The tools aren&#x27;t cmdline-compatible, but at least for now, we can</span></span><br><span class="line"><span class="comment">     seemingly get away with this by making only very minor tweaks. Thanks</span></span><br><span class="line"><span class="comment">     to Nico Weber for the idea. */</span></span><br><span class="line">  <span class="keyword">if</span> (clang_mode &amp;&amp; !afl_as) &#123;</span><br><span class="line">    use_clang_as = <span class="number">1</span>;</span><br><span class="line">    afl_as = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = <span class="string">&quot;clang&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  <span class="comment">/* Although this is not documented, GCC also uses TEMP and TMP when TMPDIR</span></span><br><span class="line"><span class="comment">     is not set. We need to check these non-standard variables to properly</span></span><br><span class="line"><span class="comment">     handle the pass_thru logic later on. */</span></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TEMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="string">&quot;/tmp&quot;</span>;</span><br><span class="line">  as_params = ck_alloc((argc + <span class="number">32</span>) * <span class="keyword">sizeof</span>(u8*));</span><br><span class="line">  as_params[<span class="number">0</span>] = afl_as ? afl_as : (u8*)<span class="string">&quot;as&quot;</span>;</span><br><span class="line">  as_params[argc] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; i++) &#123; <span class="comment">//判断要编译成32位还是64位</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--64&quot;</span>)) use_64bit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--32&quot;</span>)) use_64bit = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="comment">/* The Apple case is a bit different... */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-arch&quot;</span>) &amp;&amp; i + <span class="number">1</span> &lt; argc) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;x86_64&quot;</span>)) use_64bit = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;i386&quot;</span>))</span><br><span class="line">        FATAL(<span class="string">&quot;Sorry, 32-bit Apple platforms are not supported.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Strip options that set the preference for a particular upstream</span></span><br><span class="line"><span class="comment">       assembler in Xcode. */</span></span><br><span class="line">    <span class="keyword">if</span> (clang_mode &amp;&amp; (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-q&quot;</span>) || !<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-Q&quot;</span>)))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">    as_params[as_par_cnt++] = argv[i];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  <span class="comment">/* When calling clang as the upstream assembler, append -c -x assembler</span></span><br><span class="line"><span class="comment">     and hope for the best. */</span></span><br><span class="line">  <span class="keyword">if</span> (use_clang_as) &#123;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-x&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;assembler&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  input_file = argv[argc - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (input_file[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(input_file + <span class="number">1</span>, <span class="string">&quot;-version&quot;</span>)) &#123;</span><br><span class="line">      just_version = <span class="number">1</span>;</span><br><span class="line">      modified_file = input_file;</span><br><span class="line">      <span class="keyword">goto</span> wrap_things_up;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (input_file[<span class="number">1</span>]) FATAL(<span class="string">&quot;Incorrect use (not called through afl-gcc?)&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> input_file = <span class="literal">NULL</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Check if this looks like a standard invocation as a part of an attempt</span></span><br><span class="line"><span class="comment">       to compile a program, rather than using gcc on an ad-hoc .s file in</span></span><br><span class="line"><span class="comment">       a format we may not understand. This works around an issue compiling</span></span><br><span class="line"><span class="comment">       NSS. */</span></span><br><span class="line">      <span class="comment">/*检查这是否看起来像是编译程序的一部分，而不是在我们可能无法理解的格式上，</span></span><br><span class="line"><span class="comment">      临时使用 gcc 编译 .s 文件。此方法解决了编译 NSS 时遇到的问题。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  modified_file = alloc_printf(<span class="string">&quot;%s/.afl-%u-%u.s&quot;</span>, tmp_dir, getpid(),</span><br><span class="line">                               (u32)time(<span class="literal">NULL</span>));   <span class="comment">//临时文件</span></span><br><span class="line">wrap_things_up:</span><br><span class="line">  as_params[as_par_cnt++] = modified_file;</span><br><span class="line">  as_params[as_par_cnt]   = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;input file: %s&quot;</span>,input_file);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;modified_file: %s&quot;</span>,modified_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，edit_params函数主要的功能就是判断要生成多少位的应用程序，然后寻找tmp路径，为什么要找这个tmp路径呢？是因为在gcc汇编过程中，会生成一个.s文件，这个文件是汇编文件，存放在tmp文件夹，然后，gcc会调用汇编器as，去生成可执行文件。</p>
<h5 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h5><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_instrumentation</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">static</span> u8 line[MAX_LINE];</span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;</span><br><span class="line">  u8  instr_ok = <span class="number">0</span>, skip_csect = <span class="number">0</span>, skip_next_label = <span class="number">0</span>,</span><br><span class="line">      skip_intel = <span class="number">0</span>, skip_app = <span class="number">0</span>, instrument_next = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;</span><br><span class="line">    inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class="line">  &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;</span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line">  outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);  </span><br><span class="line">  <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line">      <span class="comment">/*在某些情况下，我们希望推迟写入插装跳板，直到所有标签、宏、注释等处理完毕。</span></span><br><span class="line"><span class="comment">      如果我们处于这种模式，并且如果该行以制表符后跟字符开头，则立即输出跳板。*/</span></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Output the actual line, call it a day in pass-thru mode. */</span></span><br><span class="line">    <span class="comment">/*在直通模式下，输出实际行并结束处理。*/</span></span><br><span class="line">    <span class="built_in">fputs</span>(line, outf);</span><br><span class="line">    <span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class="line"><span class="comment">       instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class="line"><span class="comment">       files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class="line">    <span class="comment">/*好了，真正有趣的部分开始了。首先，我们只想对 .text 部分进行插装。</span></span><br><span class="line"><span class="comment">    因此，让我们在处理过的文件中跟踪这一点，并相应地设置 instr_ok*/</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class="line"><span class="comment">         a bit annoying. They use a specific format of p2align directives</span></span><br><span class="line"><span class="comment">         around them, so we use that as a signal. */</span></span><br><span class="line">        <span class="comment">/*OpenBSD 将跳转表直接内联到代码中，这有点让人烦恼。</span></span><br><span class="line"><span class="comment">        它们在跳转表周围使用了一种特定格式的 p2align 指令，因此我们将其作为信号来处理。*/</span></span><br><span class="line">      <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">          <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Detect off-flavor assembly (rare, happens in gdb). When this is</span></span><br><span class="line"><span class="comment">       encountered, we set skip_csect until the opposite directive is</span></span><br><span class="line"><span class="comment">       seen, and we do not instrument. */</span></span><br><span class="line">    <span class="comment">/*检测到不常见的汇编（比较罕见，发生在 gdb 中）。</span></span><br><span class="line"><span class="comment">    当遇到这种情况时，我们设置 skip_csect，直到看到相反的指令为止，并且我们不进行插装。*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Detect syntax changes, as could happen with hand-written assembly.</span></span><br><span class="line"><span class="comment">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span></span><br><span class="line">    <span class="comment">/*检测语法变化，可能发生在手写的汇编中。跳过 Intel 格式的代码块，当返回到 AT&amp;T 格式时恢复插桩*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class="line"><span class="comment">       names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class="line"><span class="comment">       we want to catch:</span></span><br><span class="line"><span class="comment">         ^main:      - function entry point (always instrumented)</span></span><br><span class="line"><span class="comment">         ^.L0:       - GCC branch label</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span><br><span class="line"><span class="comment">         ^\tjnz foo  - conditional branches</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...but not:</span></span><br><span class="line"><span class="comment">         ^# BB#0:    - clang comments</span></span><br><span class="line"><span class="comment">         ^ # BB#0:   - ditto</span></span><br><span class="line"><span class="comment">         ^.Ltmp0:    - clang non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LC0       - GCC non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class="line"><span class="comment">         ^\tjmp foo  - non-conditional jumps</span></span><br><span class="line"><span class="comment">       Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class="line"><span class="comment">       with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class="line"><span class="comment">       later on.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class="line"><span class="comment">       right after the branch (to instrument the not-taken path) and at the</span></span><br><span class="line"><span class="comment">       branch destination label (handled later on). */</span></span><br><span class="line">    <span class="comment">/*条件分支指令（如 jnz 等）。</span></span><br><span class="line"><span class="comment">    我们将插装代码追加到分支指令后面（以插装未被选择的路径），并且将插装代码插入到分支目标标签处（稍后处理）。*/</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line">        ins_lines++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Label of some sort. This may be a branch destination, but we need to</span></span><br><span class="line"><span class="comment">       tread carefully and account for several different formatting</span></span><br><span class="line"><span class="comment">       conventions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="comment">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class="line">    <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">        <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">        <span class="comment">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">          <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">             That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">             processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">             typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">             about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment">             We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">             MacOS X). */</span></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line">        instrument_next = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ins_lines)</span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line">  <span class="keyword">if</span> (input_file) fclose(inf);</span><br><span class="line">  fclose(outf);</span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ins_lines) WARNF(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,</span><br><span class="line">                          pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">             ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">             getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> :</span><br><span class="line">             (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">             inst_ratio);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>该函数就是对gcc生成的.s文件做了修改，也就是插桩，可以看到只对.text段进行插桩，在text段进行插桩之后，调用汇编器as，生成可执行文件。<br>我们来看一下gcc生成的.s文件（gcc使用-S选项即可）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">	.file	<span class="string">&quot;test-instr.c&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">&quot;Hum?&quot;</span></span><br><span class="line">.LC1:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">&quot;Looks like a zero to me!&quot;</span></span><br><span class="line">.LC2:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">&quot;A non-zero value? How quaint!&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB6:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	endbr64</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">	subq	$<span class="number">32</span>, %rsp</span><br><span class="line">	movl	%edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">	movq	%rsi, <span class="number">-32</span>(%rbp)</span><br><span class="line">	movq	%fs:<span class="number">40</span>, %rax</span><br><span class="line">	movq	%rax, <span class="number">-8</span>(%rbp)</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	leaq	<span class="number">-16</span>(%rbp), %rax</span><br><span class="line">	movl	$<span class="number">8</span>, %edx</span><br><span class="line">	movq	%rax, %rsi</span><br><span class="line">	movl	$<span class="number">0</span>, %edi</span><br><span class="line">	call	read@PLT</span><br><span class="line">	testq	%rax, %rax</span><br><span class="line">	jg	.L2</span><br><span class="line">	leaq	.LC0(%rip), %rax</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	call	<span class="built_in">puts</span>@PLT</span><br><span class="line">	movl	$<span class="number">1</span>, %edi</span><br><span class="line">	call	<span class="built_in">exit</span>@PLT</span><br><span class="line">.L2:</span><br><span class="line">	movzbl	<span class="number">-16</span>(%rbp), %eax</span><br><span class="line">	cmpb	$<span class="number">48</span>, %al</span><br><span class="line">	jne	.L3</span><br><span class="line">	leaq	.LC1(%rip), %rax</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	call	<span class="built_in">puts</span>@PLT</span><br><span class="line">	jmp	.L4</span><br><span class="line">.L3:</span><br><span class="line">	leaq	.LC2(%rip), %rax</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	call	<span class="built_in">puts</span>@PLT</span><br><span class="line">.L4:</span><br><span class="line">	movl	$<span class="number">0</span>, %edi</span><br><span class="line">	call	<span class="built_in">exit</span>@PLT</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE6:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	<span class="string">&quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span></span><br><span class="line">	.section	.note.GNU-<span class="built_in">stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line">	.section	.note.gnu.property,<span class="string">&quot;a&quot;</span></span><br><span class="line">	.align <span class="number">8</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">1f</span> - <span class="number">0f</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">4f</span> - <span class="number">1f</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">5</span></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">&quot;GNU&quot;</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">	.align <span class="number">8</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">0xc0000002</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">3f</span> - <span class="number">2f</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">	.<span class="type">long</span>	<span class="number">0x3</span></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">	.align <span class="number">8</span></span><br><span class="line"><span class="number">4</span>:</span><br></pre></td></tr></table></figure></div>
<p>在插桩的时候，代码中体现：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line">        ins_lines++;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>
<p>不难看出，trampoline_fmt32和trampoline_fmt64是一个宏，这里直接添加到文件中去了，我们在<code>afl-as.h</code>文件中可以看到这两个宏：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal -16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edi,  0(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edx,  4(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%ecx,  8(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%eax, 12(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl $0x%08x, %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl 12(%%esp), %%eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  8(%%esp), %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  4(%%esp), %%edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  0(%%esp), %%edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal 16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></div>
<p>不难看出，这里的插桩就是让程序去调用函数<code>__afl_maybe_log</code>函数。<br>我们直接使用<code>afl-gcc</code>插桩生成一个文件（这里使用的是AFL项目中自带的test文件），去看一下afl_maybe_log函数：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.imgdb.cn/item/67a70eadd0e0a243d4fd032e.png"
                      alt="2-2-1 _afl_maybe_log.png"
                ><br>这里实际上只是<code>afl_maybe_log</code>函数的第一部分，也就是我们前面讲AFL原理的时候的<code>fork_server</code>。我们来看看第二部分，这部分就是我们前面讲过的路径信息反馈部分；<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.imgdb.cn/item/67a70eadd0e0a243d4fd032f.png"
                      alt="2-2-2 路径信息反馈.png"
                ><br>这里路径信息反馈的实现的原理是：在每个路径下都有一个唯一的id，实际上就是随机数，将该id作为下标，以共享内存基址作为基准，下标位置数据+1，就完成了路径信息反馈。</p>
]]></content>
      <categories>
        <category>AFL源码分析</category>
      </categories>
      <tags>
        <tag>AFL源码分析</tag>
        <tag>二进制漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>Yara（恶意样本检测工具）</title>
    <url>/2025/02/16/Yara%EF%BC%88%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%EF%BC%89/</url>
    <content><![CDATA[<p><a class="link"   href="https://virustotal.github.io/yara/" >Yara官网地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://www.cnblogs.com/Hekeats-L/p/17902549.html" >本人学习地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="一-Yara简介："><a href="#一-Yara简介：" class="headerlink" title="一.Yara简介："></a>一.Yara简介：</h2><p>YARA是一个旨在(但不限于)帮助恶意软件研究人员识别和分类恶意软件样本的工具，使用YARA，你可以基于文本或二进制模式创建关于恶意软件家族的描述(或任何你想要描述的内容)。每个描述，也就是一个规则，由一组字符串和一个布尔表达式组成，这些字符串和布尔表达式决定了它的逻辑。<br>Yara可以基于二进制和文本模式识别信息，例如识别指定文件中所包含的字符串或者十六进制(hexadecimal)。<br>规则可以被用于标记模式，例如，编写Yara规则通常是为了根据文件所呈现的特性(或模式)来确定文件是否恶意。</p>
<h2 id="二-Yara规则简介："><a href="#二-Yara规则简介：" class="headerlink" title="二.Yara规则简介："></a>二.Yara规则简介：</h2><p>Yara用于编写规则的专有语言学习起来相当简单，但很难掌握，这是因为你编写的规则的有效性取决于你对你想要搜索模式的理解。<br>使用Yara规则很简单，每个yara命令需要两个参数才能有效，它们是：</p>
<ol>
<li>我们所创建的规则文件；</li>
<li>要使用规则的文件名称、目录或进程ID。<br>每条规则都必须有名称和条件，例如，如果我们想针对目录”somedirectory”来使用”myrule.yar”规则，我们将输入如下的命令：<br><code>yara myrule.yar somedirectory</code><br><strong>.yar是所有Yara规则的标准文件拓展名</strong></li>
</ol>
<h2 id="三-Yara规则编写："><a href="#三-Yara规则编写：" class="headerlink" title="三.Yara规则编写："></a>三.Yara规则编写：</h2><h3 id="1-规则标识符："><a href="#1-规则标识符：" class="headerlink" title="1.规则标识符："></a>1.规则标识符：</h3><p>每个关键字都以<code>rule</code>开头，后面跟着一个规则标识符。<strong>该标识符遵循的规则与C语言标识符定义规则一样，由英文字母，数字，下划线组成，大小写敏感，不能以数字开头</strong>。</p>
<h3 id="2-Meta："><a href="#2-Meta：" class="headerlink" title="2.Meta："></a>2.Meta：</h3><p>在Yara规则中，<code>meta</code>是用于提供关于规则本身的元信息的部分，而不是用于定义条件的部分。<code>meta</code>节包含有关规则的描述性信息，例如作者、版本、描述等。这些元信息不直接影响规则的匹配，而是提供有关Yara规则的额外信息和说明。<br>Yara规则的这一部分是为规则的作者所保留的描述性信息。例如，你可以使用desc，description(描述)的缩写，来总结规则检查的内容，这部分中的任何内容都不会影响规则本身，与注释代码类似，总结规则也很有用。<br><em>tips：在Yara规则中，desc关键字属于meta节的一部分。</em><br>在Meta中我们可以定义一些该规则的描述信息。</p>
<h3 id="3-strings："><a href="#3-strings：" class="headerlink" title="3.strings："></a>3.strings：</h3><h4 id="十六进制字符串："><a href="#十六进制字符串：" class="headerlink" title="&lt;1&gt;.十六进制字符串："></a>&lt;1&gt;.十六进制字符串：</h4><p><strong>？：通配符，可以代替某些未知字节，与任何内容匹配</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule WildcardExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">       <span class="comment">// 使用‘?’作为通配符</span></span><br><span class="line">       $hex_string = &#123; <span class="number">00</span> <span class="number">11</span> ?? <span class="number">33</span> <span class="number">4</span>? <span class="number">55</span> &#125;</span><br><span class="line">    condition:</span><br><span class="line">       $hex_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个规则可以匹配下面的两个字符串：<br>00 11 01 33 43 55<br>00 11 AA 33 4N 55</p>
<p><strong>跳转：可以匹配长度可变的字符串</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">       <span class="comment">// 使用‘[]’作为跳转，与任何长度为0-2字节的内容匹配</span></span><br><span class="line">       $hex_string1 = &#123; <span class="number">00</span> <span class="number">11</span> [<span class="number">2</span>] <span class="number">44</span> <span class="number">55</span> &#125;</span><br><span class="line">       $hex_string2 = &#123; <span class="number">00</span> <span class="number">11</span> [<span class="number">0</span>-<span class="number">2</span>] <span class="number">44</span> <span class="number">55</span> &#125;</span><br><span class="line">       <span class="comment">// 该写法与string1作用完全相同</span></span><br><span class="line">       $hex_string3 = &#123; <span class="number">00</span> <span class="number">11</span> ?? ?? <span class="number">44</span> <span class="number">55</span> &#125;</span><br><span class="line">    condition:</span><br><span class="line">       $hex_string1 and $hex_string2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个规则可以匹配下面的两个字符串：</p>
<p>00 11 01 22 44 55<br>00 11 AA 44 55</p>
<p><strong>匹配无限长的字符串</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule BuzzLightyear</span><br><span class="line">&#123;</span><br><span class="line">	strings:</span><br><span class="line">        $hex_string = &#123; F4 <span class="number">23</span> [-] <span class="number">62</span> B4 &#125;</span><br><span class="line">    condition:</span><br><span class="line">        $hex_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个规则可以匹配下面的两个字符串：</p>
<p>F4 23 AA FF 62 B4<br>F4 23 AA AA AA AA AA…FF FF 62 B4</p>
<p><strong>也可以使用类似于正则表达式的语法</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule AlternativesExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">       $hex_string = &#123; <span class="number">00</span> <span class="number">11</span> ( <span class="number">22</span> | <span class="number">33</span> <span class="number">44</span> ) <span class="number">55</span> &#125;</span><br><span class="line">    condition:</span><br><span class="line">       $hex_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以匹配以下内容:</p>
<p>00 11  22  55<br>00 11  33 44  55</p>
<p><strong>上述方法整合使用：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">       $hex_string = &#123; <span class="number">00</span> <span class="number">11</span> ( <span class="number">33</span> <span class="number">44</span> | <span class="number">55</span> | <span class="number">66</span> ?? <span class="number">88</span> ) <span class="number">99</span> &#125;</span><br><span class="line">    condition:</span><br><span class="line">       $hex_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个规则可以匹配下面的三个字符串：</p>
<p>00 11 33 44 99<br>00 11 55 99<br>00 11 66 AG 88 99</p>
<h4 id="文本字符串："><a href="#文本字符串：" class="headerlink" title="&lt;2&gt;.文本字符串："></a>&lt;2&gt;.文本字符串：</h4><blockquote>
<p>nocase：  不区分大小写<br>wide：      匹配2字节的宽字符， 这种宽字符串在许多二进制文件中都有出现<br>ascii：      匹配1字节的ascii字符<br>xor：        匹配异或后的字符串<br>fullword： 匹配完整单词，用于匹配那些前后没有附加其他字符的单词<br>private：  定义私有字符串</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule CaseInsensitiveTextExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        <span class="comment">// 不区分大小写</span></span><br><span class="line">        $text_string = <span class="string">&quot;foobar&quot;</span> nocase</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 匹配宽字符串</span></span><br><span class="line">        $wide_string = <span class="string">&quot;Borland&quot;</span> wide</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 同时匹配2种类型的字符串</span></span><br><span class="line">        $wide_and_ascii_string = <span class="string">&quot;Borland&quot;</span> wide ascii</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 匹配所有可能的异或后字符串</span></span><br><span class="line">        $xor_string = <span class="string">&quot;This program cannot&quot;</span> xor</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 匹配所有可能的异或后wide ascii字符串</span></span><br><span class="line">        $xor_string = <span class="string">&quot;This program cannot&quot;</span> xor wide ascii</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 限定异或范围</span></span><br><span class="line">        $xor_string = <span class="string">&quot;This program cannot&quot;</span> xor(<span class="number">0x01</span>-<span class="number">0xff</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 全词匹配(匹配:www.domain.com  匹配:www.my-domain.com  不匹配:www.mydomain.com)</span></span><br><span class="line">        $wide_string = <span class="string">&quot;domain&quot;</span> fullword</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 私有字符串可以正常匹配规则，但是永远不会在输出中显示</span></span><br><span class="line">        $text_string = <span class="string">&quot;foobar&quot;</span> <span class="keyword">private</span></span><br><span class="line"> </span><br><span class="line">    condition:</span><br><span class="line">        $text_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="&lt;3&gt;.正则表达式："></a>&lt;3&gt;.正则表达式：</h4><p>yara正则表达式与Perl编程中的正则表达式相差不大。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule RegularShow</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $re1 = /md5: [<span class="number">0</span>-9a-fA-F]&#123;<span class="number">32</span>&#125;/</span><br><span class="line">        $re2 = /state: (on|off)/</span><br><span class="line">    condition:</span><br><span class="line">        $re1 and $re2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="4-condition："><a href="#4-condition：" class="headerlink" title="4.condition："></a>4.condition：</h3><p><strong>#：</strong> 计算字符串在文件或内存中出现的次数：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule CountExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="comment">//a字符串出现6次，b字符串大于10次</span></span><br><span class="line">        #a == <span class="number">6</span> and #b &gt; <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>**@：**使用<code>@a[i]</code>可以获取$a字符串在文件或者内存中第i次出现时的偏移或虚拟地址。<em>注意索引从1开始的，如果字符串出现次数小于i，则返回NaN</em><br>**!：**使用<code>!a[i]</code>可以获取字符串$a在文件或者内存中，第i次出现时的字符串长度。<em>下标从1开始，!a是!a[1]的简写</em>。</p>
<p><strong>at：</strong> 匹配字符串在文件或内存中的偏移</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule AtExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="comment">// a和b字符串出现在文件或内存的100和200偏移处</span></span><br><span class="line">        $a at <span class="number">100</span> and $b at <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>in：</strong> 在文件的某个地址范围内匹配字符串</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule InExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        $a <span class="title function_">in</span> <span class="params">(<span class="number">0.</span><span class="number">.100</span>)</span> and $b <span class="title function_">in</span> <span class="params">(<span class="number">100.</span>.filesize)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>filesize：</strong> 获取文件大小</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">filesize</span><br><span class="line"><span class="comment">// 使用关键字匹配文件大小</span></span><br><span class="line">rule FileSizeExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">       <span class="comment">// filesize只在文件时才有用，对进程无效</span></span><br><span class="line">       <span class="comment">// KB MB后缀只能与十进制大小一起使用</span></span><br><span class="line">       filesize &gt; 200KB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>entrypoint：</strong> 获取PE或ELF文件入口点：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配PE或ELF文件入口点(高版本请使用PE模块的pe.entry_point代替)</span></span><br><span class="line">rule EntryPointExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &#123; E8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> &#125;</span><br><span class="line">    condition:</span><br><span class="line">       $a at entrypoint</span><br><span class="line">&#125;</span><br><span class="line">rule EntryPointExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &#123; 9C <span class="number">50</span> <span class="number">66</span> A1 ?? ?? ?? <span class="number">00</span> <span class="number">66</span> A9 ?? ?? <span class="number">58</span> <span class="number">0F</span> <span class="number">85</span> &#125;</span><br><span class="line">    condition:</span><br><span class="line">       $a <span class="title function_">in</span> <span class="params">(entrypoint..entrypoint + <span class="number">10</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>of：</strong> 匹配多个字符串中的某几个</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule OfExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line">        $c = <span class="string">&quot;dummy3&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        <span class="comment">// 3个字符串只需匹配任意2个</span></span><br><span class="line">        <span class="number">2</span> of ($a,$b,$c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>for xxx of xxx : (xxx)：</strong> 对多个字符串匹配相同的条件</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="keyword">for</span> AAA of BBB : ( CCC )</span><br><span class="line">含义：</span><br><span class="line">在BBB字符串集合中，至少有AAA个字符串，满足了CCC的条件表达式，才算匹配成功。</span><br><span class="line">在CCC条件表达式中，可以使用<span class="string">&#x27;$&#x27;</span>依次代替BBB字符串集合中的每一个字符串。</span><br><span class="line"><span class="comment">// for..of其实就是of的特别版，所以下面2个例子作用相同</span></span><br><span class="line">any <span class="title function_">of</span> <span class="params">($a,$b,$c)</span></span><br><span class="line"><span class="keyword">for</span> any <span class="title function_">of</span> <span class="params">($a,$b,$c)</span> : ( $ )</span><br><span class="line"><span class="comment">// 在abc这3个字符串集合中，至少有1个字符串，必须满足字符串内容与entrypoint相同的条件。$表示集合中的所有字符串. 本例中, 它是字符串$a, $b和$c.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">1</span> of ($a,$b,$c) : ( $ at entrypoint  )</span><br><span class="line"><span class="keyword">for</span> any <span class="title function_">of</span> <span class="params">($a,$b,$c)</span> : ( $ at entrypoint  )</span><br><span class="line"><span class="comment">// 所有字符串，在文件或内存中出现的次数必须大于3，才算匹配成功。</span></span><br><span class="line"><span class="keyword">for</span> all of them : ( # &gt; <span class="number">3</span> )</span><br><span class="line"><span class="comment">// 所有以$a开头的字符串，在文件或内存中第2次出现的位置必须小于9</span></span><br><span class="line"><span class="keyword">for</span> all <span class="title function_">of</span> <span class="params">($a*)</span> : (@[<span class="number">2</span>] &lt; <span class="number">0x9</span>)</span><br></pre></td></tr></table></figure></div>
<p><strong>引用其他规则：</strong> </p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule Rule1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        $a</span><br><span class="line">&#125;</span><br><span class="line">rule Rule2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        $a and Rule1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>全局规则：</strong></p>
<p>全局规则可以在匹配目标文件之前，优先筛选</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">**global** rule SizeLimit</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        filesize &lt; 2MB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>私有规则：</strong></p>
<p>私有规则（private rule）可以避免规则匹配结果的混乱，</p>
<p>比如使用私有规则进行匹配时，YARA不会输出任何匹配到的私有规则信息</p>
<p>私有规则单独使用意义不大，一般可以配合”引用其它规则”的功能一起使用。比如为了判断文件是否恶意, 有这样一条私有规则, 要求文件必须是ELF文件. 一旦满足这个要求, 随后就会执行下一条规则. 但我们在输出里想看的并不是该文件它是不是ELF, 我们只想知道文件是否恶意, 那么私有规则就派上用场了.</p>
<p>私有规则也可以和全局规则一起使用，只要添加“Private”、“global”关键字即可</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> rule PrivateRuleExample</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>规则标签：</strong></p>
<p>规则标签可以让你在yara输出的时候，只显示你感兴趣的规则，而过滤掉其他规则的输出信息：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule TagsExample1 : Foo Bar Baz</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">rule TagsExample2 : Bar</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>导入模块：</strong></p>
<p>导入模块之后，可以使用导出的变量或者函数</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;pe&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;cuckoo&quot;</span></span><br><span class="line">pe.entry\_point == <span class="number">0x1000</span></span><br><span class="line">cuckoo.http\_request(/someregexp/)</span><br></pre></td></tr></table></figure></div>
<p><strong>文件包含：</strong></p>
<p>可以将其他规则包含到当前文件中</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用于C语言一样，可以包含其它规则到当前文件中</span></span><br><span class="line">include <span class="string">&quot;other.yar&quot;</span></span><br><span class="line"><span class="comment">// 相对路径</span></span><br><span class="line">include <span class="string">&quot;./includes/other.yar&quot;</span></span><br><span class="line">include <span class="string">&quot;../includes/other.yar&quot;</span></span><br><span class="line"><span class="comment">// 全路径</span></span><br><span class="line">include <span class="string">&quot;/home/plusvic/yara/includes/other.yar&quot;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>yara</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建/运营指南</title>
    <url>/2025/01/22/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%8C%E8%BF%90%E8%90%A5%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="一-准备"><a href="#一-准备" class="headerlink" title="一.准备"></a>一.准备</h1><ul>
<li>需要GitHub账号</li>
<li>安装node.js和npm<br>  在<a class="link"   href="https://nodejs.org/en/download/package-manager" >Node官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载Node，我使用的安装程序，直接无脑安装就行了，下载完成之后，使用命令<code>node -v</code>看看安装好了没，然后使用命令<code>npm -v</code>再次查看安装成功了没。</li>
<li>安装Git：<br>  在<a class="link"   href="https://git-scm.com/" >Git官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>安装最新版本，这里如果你不是程序员或者说不想研究git的话装不装无所谓，因为hexo可以一键部署，我当时也不会Git，但是想着学习一下，因为还是很重要的，所以就去学习了，安装成功之后，右键鼠标就会有<code>Open Git Bash here</code>:<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/66c89de9d9c307b7e9c7fab4.png"
                      alt="Git"
                ></li>
<li>安装Hexo框架：<br>  主题框架需要借助npm包管理器来安装：  <div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure></div>
  完成之后，用shell进到你想要保存博客所有东西的目录（这里的hexo_blog就是文件夹的名称，该命令会创建一个文件夹，该文件夹保存博客的所有东西）:  <div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init hexo_blog</span><br><span class="line">cd hexo_blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></div>
至此，我们需要的东西基本上都准备好了。</li>
</ul>
<h1 id="二-搭建博客"><a href="#二-搭建博客" class="headerlink" title="二.搭建博客"></a>二.搭建博客</h1><p>首先我们需要创建一个GitHub项目，需要注意的是，这个项目需要以<code>&lt;用户名&gt;.github.io</code>命名。</p>
<ul>
<li>更换主题：<br>  hexo的默认界面说实话有点小丑，我们可以到<a class="link"   href="https://hexo.io/themes/" >这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>选择我们想要的主题，这里我们可以用这种方式下载主题：  <div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo-blog</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></div>
  如果这种方式有点慢或者说下不下来的话，你可以直接到主题的GitHub页面把项目全部下载下来，然后保存到<code>themes/next</code>目录下，完成之后修改博客根目录下的<code>_config.yml</code>:  <div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">redefine</span></span><br></pre></td></tr></table></figure></div>
  好了，现在你可以使用命令<code>hexo g</code>,<code>hexo s</code>，正常启动之后在浏览器使用<code>localhost:4000</code>查看是否搭建成功。如果本地没有问题的话，就可以上传到github了<br>  这里需要注意，只需要上传public目录就可以了，我当时学习搭建的时候没有看到，直接把博客的根目录传上去了，折腾了好久</li>
</ul>
<p>其实每个主题都是有官方文档的，可以看着文档自己diy一下。<br>完成这些之后，你就可以上传到GitHub了：</p>
<ul>
<li>方法一（使用Git）：<br>  首先Open Git Bash here</li>
</ul>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git init -b main</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Fitst commit&quot; #提交信息</span><br><span class="line">git remote add origin https://github.com/Shad0hun/Shad0hun.github.io.git</span><br><span class="line">git remote -v #验证远程仓库</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure></div>
<p>如果你使用https上传不了的话，建议多试几次，或者使用ssh上传。</p>
<ul>
<li>方法二（一键部署）：<br>  这个方法需要我们修改<code>_config.yml</code>：</li>
</ul>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Deployment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/Shad0hun/Shad0hun.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></div>
<p>这里如果不想用shh，一定要安装插件：<br><code> npm install hexo-deployer-git --save</code><br>然后使用命令<code>hexo d</code>一键部署，如果不成功的话，还是建议多试几次或者将https改为ssh进行上传。<br>完成上面的工作，实际上我们已经可以在自己的网站上看到博客了，如果看不到的话，去看看GitHub Pages有没有正常工作。</p>
<h1 id="三-博客运营"><a href="#三-博客运营" class="headerlink" title="三.博客运营"></a>三.博客运营</h1><p>修改<code>_config.yml</code>文件：<code>post_asset_folder: true</code>即可在生成文章的时候生成一个同名资源目录用于存放图片文件。<br>这里主要介绍hexo的一些指令，主要就是发布文章，同步到GitHub的一些操作。</p>
<ul>
<li>新建博客并初始化：<code>hexo init [folder]</code></li>
<li>新建文章：<code>hexo new [layout] &lt;title&gt;</code></li>
<li>生成静态文件：<code>hexo generate</code>，这实际上就是把我们的.md文件生成为html文件</li>
<li>发布草稿：<code>hexo publish [layout] &lt;filename&gt;</code></li>
<li>部署网站：<code>hexo deploy</code></li>
<li>清理缓存文件：<code>hexo clean</code></li>
<li>获取配置：<code>hexo config</code></li>
<li>将草稿帖子从 _drafts 移动到 _posts 文件夹：<code>hexo publish</code><br>这里再来说一下文章标签：<blockquote>
<p>title:网页文章标题<br>date:文章创建如期<br>comments:文章评论功能是否启动<br>tags:文章标签<br>categories:文章分类<br>keywords:文章关键字</p>
</blockquote>
</li>
</ul>
<p>最后，附上参考播客：<a class="link"   href="https://blog.csdn.net/yaorongke/article/details/119089190" >GitHub Pages + Hexo搭建个人博客网站，史上最全教程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>入侵检测系统：Snort</title>
    <url>/2025/02/16/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%EF%BC%9ASnort/</url>
    <content><![CDATA[<h1 id="一-系统安装："><a href="#一-系统安装：" class="headerlink" title="一.系统安装："></a>一.系统安装：</h1><p>当时安装的时候看的这一篇文档，感觉还可以：<a class="link"   href="https://www.jianshu.com/p/9296cb4131b5" >安装文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>本人环境：<code>Ubuntu22.04</code></p>
<ol>
<li>安装libpcap:<br><a class="link"   href="https://links.jianshu.com/go?to=http://www.tcpdump.org/" >官网下载<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，其实如果用过<code>tcpdump</code>的话这个是默认安装的。</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.tcpdump.org/release/libpcap-1.10.0.tar.gz</span><br><span class="line">tar -zxvf ./libpcap-1.10.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> ./libpcap-1.10.0.tar.gz</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">最后需要有这一步：</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /usr/local/lib/libpcap.* /usr/lib/</span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li>安装LuaJIT:<br><a class="link"   href="https://links.jianshu.com/go?to=http://luajit.org/download.html" >官网下载<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>（这个可以不安装）</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://luajit.org/git/luajit.git</span><br><span class="line"><span class="built_in">cd</span> ./luajit</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li>daq安装:</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.snort.org/downloads/snort/daq-2.0.7.tar.gz</span><br><span class="line">tar -zxvf ./daq-2.0.7.tar.gz</span><br><span class="line"><span class="built_in">cd</span> .//daq-2.0.7</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>
<ol start="4">
<li>依赖安装:</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install bison flex </span><br></pre></td></tr></table></figure></div>
<ol start="5">
<li>Snort安装:</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">get https://www.snort.org/downloads/snort/snort-2.9.20.tar.gz</span><br><span class="line">tar -zxvf ./snort-2.9.20.tar.gz</span><br><span class="line"><span class="built_in">cd</span> ./snort-2.9.20</span><br><span class="line">./configure --enable-sourcefire</span><br></pre></td></tr></table></figure></div>
<h2 id="报错解决："><a href="#报错解决：" class="headerlink" title="报错解决："></a>报错解决：</h2><h3 id="1-check"><a href="#1-check" class="headerlink" title="1.check"></a>1.check</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">No package <span class="string">&#x27;check&#x27;</span> found Consider adjusting the PKG_CONFIG_PATH environment variable <span class="keyword">if</span> you installed software <span class="keyword">in</span> a non-standard prefix. Alternatively, you may <span class="built_in">set</span> the environment variables CHECK_CFLAGS and CHECK_LIBS to avoid the need to call pkg-config. See the pkg-config man page <span class="keyword">for</span> more details.</span><br></pre></td></tr></table></figure></div>
<p>这个是因为没有check库，我们安装一下就好：<br><code>sudo apt-get install check</code></p>
<h3 id="2-daq"><a href="#2-daq" class="headerlink" title="2.daq"></a>2.daq</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">checking <span class="keyword">for</span> daq_load_modules <span class="keyword">in</span> -ldaq_static... no ERROR! daq_static library not found, go get it from http://www.snort.org/.</span><br></pre></td></tr></table></figure></div>
<p>这个错误是因为没有正确安装daq，按照前面安装daq的方法重新安装。</p>
<h3 id="3-luajit"><a href="#3-luajit" class="headerlink" title="3.luajit"></a>3.luajit</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">checking <span class="keyword">for</span> luajit... no ERROR! LuaJIT library not found. Go get it from http://www.luajit.org/ (or) Try compiling without openAppId using <span class="string">&#x27;--disable-open-appid&#x27;</span> configure: error: <span class="string">&quot;Fatal!&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>这个错误是因为系统找不到<code>LuaJIT</code>库，如果不需要<code>openAppId</code>功能的话，可以将其屏蔽：<br><code>./configure --disable-open-appid</code></p>
<h3 id="4-rcp-h"><a href="#4-rcp-h" class="headerlink" title="4.rcp.h"></a>4.rcp.h</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">en -Wall -c -o sp_rpc_check.o sp_rpc_check.c sp_rpc_check.c:32:10: fatal error: rpc/rpc.h: 没有那个文件或目录 32 | <span class="comment">#include &lt;rpc/rpc.h&gt; | ^~~~~~~~~~~ compilation terminated. make[3]: *** [Makefile:489：sp_rpc_check.o] 错误 1 make[3]: 离开目录“/home/shad0hun/snort-2.9.20/src/detection-plugins” make[2]: *** [Makefile:594：install] 错误 2 make[2]: 离开目录“/home/shad0hun/snort-2.9.20/src/detection-plugins” make[1]: *** [Makefile:558：install-recursive] 错误 1 make[1]: 离开目录“/home/shad0hun/snort-2.9.20/src” make: *** [Makefile:516：install-recursive] 错误 1</span></span><br></pre></td></tr></table></figure></div>
<p>这个问题是因为系统找不到指定文件，不要尝试修改Makefile，因为每次.&#x2F;config它都会重置Makefile。<br>解决方法：<br>使用命令<code>sudo find /usr -name &quot;rpc.h&quot;</code>找一下文件位置，我这里是位于<code>/usr/include/ntirpc/rpc/rpc.h</code>。<br>然后我们进入该目录，我们只要将<code>ntirpc</code>目录下的所有内容放到<code>/usr/include/</code>目录下即可。</p>
<h1 id="二-Snort概述："><a href="#二-Snort概述：" class="headerlink" title="二.Snort概述："></a>二.Snort概述：</h1><p>1.嗅探器模式：只是从网络读取数据包并在控制台上以连续流的形式显示<br>2.数据包记录模式：将数据包记录到磁盘<br>3.网络入侵检测系统（NIDS）模式：对网络流量进行检测和分析。</p>
<h2 id="1-嗅探器模式"><a href="#1-嗅探器模式" class="headerlink" title="1.嗅探器模式"></a>1.嗅探器模式</h2><p>所谓的嗅探器模式就是Snort从网络上读出的数据包然后显示在控制台上。<br>如果只想将TCP&#x2F;IP数据包头打印到屏幕上：<br><code>snort -v</code><br>启动之后，我ping了该主机，可以看到效果：<br>![[1.1 v.png]]<br>可以观察到，我们只能看到IP和TCP&#x2F;UDP&#x2F;TCMP标头，不显示其他任何内容。<br>如果想查看其中的应用层数据：<br><code>snort -vd</code><br>![[1.1 vd.png]]<br>可以看到，我们现在不仅能看到头数据，还能看到应用层数据。<br>如果要更具体的显示，比如要显示数据链路层报文头：<br><code>snort -vde</code><br>![[1.1 vde.png]]<br>观察发现，多出来的信息：</p>
<blockquote>
<p>02&#x2F;12-14:21:38.474048 00:50:56:C0:00:08 -&gt; 00:0C:29:07:0C:E9 type:0x800 len:0x4A</p>
</blockquote>
<p>很明显这其中包含了MAC地址信息，这是数据链路层的报文头。<br>最后，这些命令开关也可以单独使用：例如，最后一个命令我们可以这样输入：<br><code>snort -v -d -e</code><br>那么就是说：<br>-v : 打印IP数据报文头<br>-d : 打印应用层数据<br>-e : 打印数据链路层报文头</p>
<h2 id="2-数据包记录模式"><a href="#2-数据包记录模式" class="headerlink" title="2.数据包记录模式"></a>2.数据包记录模式</h2><p>该模式就是吧数据包都记录到磁盘上，使用的时候我们需要指定一个日志记录，Snort就会自动记录数据包：<br><code>snort -dev -l ./log</code><br>那么我们将会在.&#x2F;log文件夹下面看到捕获到的数据包文件。<br>注意需要我们事先创建好log文件夹，如果没有，Snort 将退出并显示错误消息。<br><strong>日志命名规则：后缀为时间戳或远程主机IP地址。</strong><br>如果想要只对本地网络进行日志：<br><code>snort -dev -l ./log -h 192.168.175.0/24</code><br>这个命令告诉Snrot，将进入C类网络92.168.175的所有数据记录到.&#x2F;log文件夹中。<br>如果你使用高速网络或者希望将数据包记录为更紧凑的形式以供以后分析，则应考虑以二进制模式记录：<br><code>snort -l ./log -b</code><br>-b模式下，我们不需要指定-d , -e等选项，因为-b选项默认将所有信息都记录下来。<br>一旦数据包被记录到二进制文件中，我们可以使用tcpdump等读取文件。<br><strong>此外，Snort还可以使用-r开关读出数据包，该开关将其置于回放模式。</strong> 如果你想在嗅探器模式下通过Snort运行二进制日志文件将其数据包显示到屏幕上：<br><code>snort -dv -r filename</code><br>![[1.1 r.png]]<br>在日治包和入侵检测模式下，通过BPF(BSD Packet Filter)接口，可以使用许多方式维护日志文件中的数据。<br>例如，你想从日志文件中提取ICMP包：<br><code>/snort -dvr packet.log icmp</code><br>最后的输出还是像嗅探模式那样将数据包信息打印在控制台中。</p>
<h2 id="3-网络入侵检测系统模式"><a href="#3-网络入侵检测系统模式" class="headerlink" title="3.网络入侵检测系统模式"></a>3.网络入侵检测系统模式</h2><p>要启用网络入侵检测系统(NIDS)模式，以便不记录通过网络发送的每一个数据包：<br><code>snort -dev -l ./log -h 192.168.1.0/24 -c snort.conf</code><br>其中，<code>snort.conf</code>是配置文件，也是规则集文件。Snort会对每个包和规则集进行匹配，发现这样的包就采取行动。如果不指定输出目录，Snort就输出到<code>/var/log/snort</code>目录。<br>注意：如果你想长期使用snort作为自己的入侵检测系统，最好不要使用-v选项。因为使用这个选项，使snort向屏幕上输出一些信息，会大大降低snort的处理速度，从而在向显示器输出的过程中丢弃一些包。<br>此外，在大多数下情况下，也没必要记录数据链路层包头，所以-e选项也可以不用：<br><code>./snort -d -h 192.168.1.0/24 -l ./log -c snort.conf</code><br>这是使用Snort作为网络入侵检测系统最基本的形式,将 Snort 配置为以其最基本的 NIDS 形式运行，使用分层目录结构（就像数据包记录器模式一样），将触发 snort.conf 中指定规则的数据包以纯 ASCII 格式记录到磁盘</p>
<h3 id="NIDS模式输出选项"><a href="#NIDS模式输出选项" class="headerlink" title="&lt;1&gt;.NIDS模式输出选项"></a>&lt;1&gt;.NIDS模式输出选项</h3><p>在NIDS模式下，有很多方式配置Snort的输出。在默认情况下，Snort以ASCII格式记录日志，使用full报警机制。如果使用full报警机制，Snort会在包头之后打印报警信息，如果你不需要日志包，则可以使用-N选项。<br>Snort有6种报警机制：full、fast、socket、syslog、smb(winpopup)和none。其中有4个可以在命令行状态下使用-A选项设置。这4个是：</p>
<table>
<thead>
<tr>
<th>-A fast:</th>
<th>报警信息包括：时间戳，报警信息，源&#x2F;目的IP地址以及端口</th>
</tr>
</thead>
<tbody><tr>
<td>-A full</td>
<td>默认报警模式，这是默认的警报模式，如果您未指定模式，它将自动使用</td>
</tr>
<tr>
<td>-A unsock</td>
<td>把报警发送到一个UNIX套接字，需要有一个程序进行时监听，这样可以实现事实报警</td>
</tr>
<tr>
<td>-A none</td>
<td>关闭报警机制</td>
</tr>
<tr>
<td>-A console</td>
<td>将fast样式’警报发送到控制台</td>
</tr>
<tr>
<td>-A cmg</td>
<td>生成“cmg样式”警报</td>
</tr>
<tr>
<td>这里我们就看一下这几种区别：</td>
<td></td>
</tr>
<tr>
<td><strong>&#x3D;&#x3D;-A fast:&#x3D;&#x3D;</strong></td>
<td></td>
</tr>
<tr>
<td>![[2.1 fast.png]]</td>
<td></td>
</tr>
<tr>
<td>fast选项下，我们可以看到，会记录时间，后面这三个数字，在下面&#x3D;&#x3D;《了解警报输出》&#x3D;&#x3D;会有讲解，我们自己写的msg，priority，数据包类型，源，目的端口。</td>
<td></td>
</tr>
<tr>
<td>&#x3D;&#x3D;<strong>-A full：&#x3D;&#x3D;</strong></td>
<td></td>
</tr>
<tr>
<td>![[2.1 full.png]]</td>
<td></td>
</tr>
<tr>
<td>full选项下，可以看到记录比fast选项详细了很多。</td>
<td></td>
</tr>
<tr>
<td><strong>&#x3D;&#x3D;-A console：&#x3D;&#x3D;</strong></td>
<td></td>
</tr>
<tr>
<td>console选项则将alert直接输出到控制台：</td>
<td></td>
</tr>
<tr>
<td>![[2.1 console.png]]</td>
<td></td>
</tr>
<tr>
<td><strong>&#x3D;&#x3D;-A cmg:&#x3D;&#x3D;</strong></td>
<td></td>
</tr>
<tr>
<td>![[2.1 cmg.png]]</td>
<td></td>
</tr>
</tbody></table>
<p>使用-s选项可以使snort把报警消息发送到syslog，默认的设备是LOG_AUTHPRIV和LOG_ALERT。可以修改snort.conf文件修改其配置。</p>
<ul>
<li>登录到默认（解码的 ASCII）功能并将警报发送到 syslog<br><code>./snort -c snort.conf -l ./log -h 192.168.6.0/24 -s</code></li>
<li>登录到 &#x2F;var&#x2F;log &#x2F;snort 中的默认工具，并将警报发送到快速警报文件<br><code>./snort -c snort.conf -A fast-h 192.168.6.0/24</code></li>
</ul>
<h3 id="了解标准警报输出"><a href="#了解标准警报输出" class="headerlink" title="&lt;2&gt;.了解标准警报输出"></a>&lt;2&gt;.了解标准警报输出</h3><p>Snort生成警报消息时，通常如下所示：<br><code>[**] [116:56:1] (snort_decoder): T/TCP Detected [**]</code><br>对于[116:56:1]:<br>第一个数字是生成器ID，它告诉用户Snort的哪个组件生成了此警报，在这种情况下，我们知道此时间来自Snort的“解码”（116）组件。<br>第二个数字是Snort ID也就是SID，我们写Snort规则的时候写的哪个sid。<br>第三个数字是修订ID，此数字主要在编写签名时使用，因为规则的每个表示形式都应使用rev选项将该数字递增。</p>
<h3 id="作为守护进程运行"><a href="#作为守护进程运行" class="headerlink" title="&lt;3&gt;.作为守护进程运行"></a>&lt;3&gt;.作为守护进程运行</h3><p>如果要将 Snort 作为守护进程运行，可以将 -D 开关添加到前面部分中描述的任意组合。请注意，如果您希望能够通过向守护进程发送 SIGHUP 信号来重新启动 Snort，则_必须_在启动时指定 Snort 二进制文件的完整路径，例如：<br><code>/usr/local/bin/snort -d -h 192.168.1.0/24 -l /var/log/snortlogs -c /usr/local/etc/snort.conf -s -D</code></p>
<h2 id="4-snort-conf配置文件"><a href="#4-snort-conf配置文件" class="headerlink" title="4.snort.conf配置文件"></a>4.snort.conf配置文件</h2><blockquote>
<ol>
<li>Set the network variables.  设置各类网络地址，规则中易于使用</li>
<li>Configure the decoder      设置解码器</li>
<li>Configure the base detection engine  设置基础检测引擎</li>
<li>Configure dynamic loaded libraries   设置动态链接库</li>
<li>Configure preprocessors     设置预处理器</li>
<li>Configure output plugins    设置输出插件</li>
<li>Customize your rule set     设置自定义规则</li>
<li>Customize preprocessor and decoder rule set设置预处理、解码器规则</li>
<li>Customize shared object rule set 设置共享对象规则集</li>
</ol>
</blockquote>
<h1 id="三-Snort规则编写"><a href="#三-Snort规则编写" class="headerlink" title="三.Snort规则编写"></a>三.Snort规则编写</h1><p>大多数Snort规则都写在一行中，Snort规则分为两个逻辑部分：规则头和规则选项。<br>规则头包含规则的操作，协议，源和目的ip地址和子网掩码，以及源和目的端口信息。规则选项部分包含警报消息以及有关检查数据包的哪些部分以及确定是否采取规则操作的信息。<br>![[3.1 snort.png]]<br>第一个括号之前的文本是规则头，括号内的部分包含规则选项。规则选项部分中，括号之前的单词称为选项关键字。<br>构成规则的所有元素必须为真，才能执行值是否的规则操作。当这些元素放在一起时，可以视为形成逻辑AND语句。同时，Snort规则集中的各种规则可以视为大型OR语句。</p>
<h2 id="1-规则头"><a href="#1-规则头" class="headerlink" title="1.规则头"></a>1.规则头</h2><p>规则头包含了定义数据包的谁，哪里和什么信息，以及出现具有规则中知识的所有属性的规则包时应该执行的操作。</p>
<h3 id="规则操作"><a href="#规则操作" class="headerlink" title="&lt;1&gt;.规则操作"></a>&lt;1&gt;.规则操作</h3><p>Snort规则中的第一项就是规则操作，规则操作告诉Snort在找到符合规则条件的数据包时要做什么。Snort中有3个可用的默认操作：alert（警报），log（记录），pass（忽略）。此外，如果你以内联模式运行Snort，则您还有其他的选项，包括drop（阻止并记录），reject（阻止）和sdrop（阻止但不记录）。<br>另外，也可以定义自己的规则类型，并将一个或者多个输出插件与其关联，然后，你可以将规则类型用作Snort规则中的操作。<br>示例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ruletype suspicious&#123;</span><br><span class="line">	type log output</span><br><span class="line">	log_tcpdump:suspicious.log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此示例将创建一个记录到 syslog 和 tcpdump 的规则类型:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ruletype redalert</span><br><span class="line">   &#123;</span><br><span class="line">         type alert </span><br><span class="line">         output alert_syslog: LOG_AUTH LOG_ALERT </span><br><span class="line">         output log_tcpdump: suspicious.log</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="协议"><a href="#协议" class="headerlink" title="&lt;2&gt;.协议"></a>&lt;2&gt;.协议</h3><p>规则中的下一个字段是协议，Snort目前分析可疑行为的协议有四种：<code>tcp,udp,icmp和ip</code>,将来可能会更多，比如<code>arp,igrp,gre,ospf,rip,ipx</code>等。</p>
<h3 id="ip地址"><a href="#ip地址" class="headerlink" title="&lt;3&gt;.ip地址"></a>&lt;3&gt;.ip地址</h3><p>规则头的下一个部分决定了那些ip可以触发该规则。<br>关键字”any”可以被用来定义任何地址。<br>Snort没有提供根据ip地址查询域名的机制。地址就是由直接的数字型ip地址和一个cidr块组成的。Cidr块指示作用在规则地址和需要检查的进入的任何包的网络掩码。&#x2F;24表示c类网络，&#x2F;16表示b类网络，&#x2F;32表示一个特定的机器的地址。例如，192.168.1.0&#x2F;24代表从192.168.1.1到192.168.1.255的地址块。在这个地址范围的任何地址都匹配使用这个192.168.1.0&#x2F;24标志的规则。这种记法给我们提供了一个很好的方法来表示一个很大的地址空间。<br>有一个操作符可以应用在ip地址上，它是否定运算符（!）。这个操作符告诉snort匹配除了列出的ip地址以外的所有ip地址。否定操作符用”！”表示。下面这条规则对任何来自本地网络以外的流都进行报警。<br>比如：<code>alert tcp !192.168.1.0/24 any -&gt; 192.168.1.0/24 111(content:&quot;|00 01 86 a5|&quot;;msg:&quot;external mountd access&quot;;)</code><br>这条规则表示：任何源ip和目的ip地址不是来自内部网络，且目的端口不为111的tcp数据包。<br>此外，还可以指定ip地址列表，IP地址列表通过在方括号内将逗号分隔ip地址和CIDR块列表来指定。<br>示例：<br><code>alert tcp ![192.168.1.0/24,10.1.1.0/24] any -&gt; [192.168.1.0/.24,10.1.1.0/24] 111 (content:&quot;|00 01 86 a5|&quot;;msg:&quot;external mountd access&quot;;)</code></p>
<h3 id="端口号："><a href="#端口号：" class="headerlink" title="&lt;4&gt;.端口号："></a>&lt;4&gt;.端口号：</h3><p>端口号可以用多种方式指定，包括任意端口，静态端口，端口范围和非运算符。任意端口时通配符，静态端口即为指定单个端口，端口范围用:表示，范围运算符可以用多种方式表示：<br><code>log udp any any -&gt; 192.168.1.0/24 1:1024</code>源ip，端口为任意，目的IP为192.168.1.0&#x2F;24内任意一个，目的端口范围为1~1024<br><code>log tcp any any-&gt; 192.168.1.0/24 :6000</code>源ip，端口为任意，目的IP为192.168.1.0&#x2F;24内任意一个，目的端口范围为：小于等于6000<br><code>log tcp any :1024 -&gt; 192.168.1.0/24 500:</code>源ip为任意，源端口小于等于1024，目的IP为192.168.1.0&#x2F;24内任意一个，目的端口范围为：大于或等于6000</p>
<h3 id="方向运算符"><a href="#方向运算符" class="headerlink" title="&lt;3&gt;.方向运算符"></a>&lt;3&gt;.方向运算符</h3><p>方向运算符<code>-&gt;</code>表示规则适用的流量的方向,方向运算符左侧的 IP 地址和端口号被视为来自源主机的流量，而方向运算符右侧的地址和端口信息是目标主机的流量。还有一个双向运算符，用符号<code>&lt;&gt;</code>表示。这告诉 Snort 考虑源方向或目标方向的地址&#x2F;端口对。这对于记录&#x2F;分析对话的双方（例如 telnet 或 POP3 会话）非常方便。</p>
<h2 id="2-规则选项："><a href="#2-规则选项：" class="headerlink" title="2.规则选项："></a>2.规则选项：</h2><p>规则选项是 Snort 入侵检测引擎的核心，集易用性、强大功能和灵活性于一身。所有 Snort 规则选项都使用分号 (;) 字符相互分隔。规则选项关键字与其参数使用冒号 (:) 字符分隔。</p>
<p>规则选项主要有四类：<br><strong>general</strong><br>这些选项提供有关规则的信息，但在检测期间不会产生任何影响<br><strong>payload</strong><br>这些选项都在数据包有效负载内查找数据，并且可以相互关联<br><strong>non-payload</strong><br>这些选项寻找非有效载荷数据<br><strong>post-detection</strong><br>这些选项是规则特定的触发器，在规则“触发”后发生。</p>
<h3 id="1）一般规则选项"><a href="#1）一般规则选项" class="headerlink" title="1）一般规则选项"></a>1）一般规则选项</h3><h4 id="msg"><a href="#msg" class="headerlink" title="&#x3D;&#x3D;msg&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;msg&#x3D;&#x3D;</strong></h4><p>msg 规则选项告诉日志记录和警报引擎要与数据包转储一起打印的消息或警报。它是一个简单的文本字符串，利用 <code>\ </code>作为转义字符，用来指示可能混淆 Snort 规则解析器的离散字符（例如分号 ; 字符）。<br><code>msg:&quot;&lt;message text&gt;&quot;;</code></p>
<h4 id="reference"><a href="#reference" class="headerlink" title="&#x3D;&#x3D;reference&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;reference&#x3D;&#x3D;</strong></h4><p>引用关键字允许规则包含对外部攻击识别系统的引用。该插件目前支持多个特定系统以及唯一 URL。输出插件将使用此插件提供有关所生成警报的其他信息的链接。</p>
<p>请务必查看 <a class="link"   href="http://www.snort.org/pub-bin/sigs-search.cgi/" >http://www.snort.org/pub-bin/sigs-search.cgi/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，以了解基于sid 索引警报描述的系统</p>
<h4 id="gid"><a href="#gid" class="headerlink" title="&#x3D;&#x3D;gid&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;gid&#x3D;&#x3D;</strong></h4><p>gid关键字用于标识在触发特定规则时Snort的哪个部分生成事件。例如，gid 1与规则子系统相关联，并且为特定的预处理器和解码器指定超过100的各种gid。请参阅源代码树中的etc&#x2F;generators以获取当前使用的生成器ID。请注意，gid关键字是可选的，如果没有在规则中指定，它将默认为1，并且规则将成为通用规则子系统的一部分。为了避免与Snort中定义的gids（由于某些原因，它没有注意到etc&#x2F;generators）发生冲突，建议使用从1，000，000开始的值。对于常规规则编写，不建议使用gid关键字。此选项应与sid关键字一起使用。(See部分）<br><code>gid:&lt;generator id&gt;;</code></p>
<h4 id="sid"><a href="#sid" class="headerlink" title="&#x3D;&#x3D;sid&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;sid&#x3D;&#x3D;</strong></h4><p>sid关键字用于唯一标识Snort规则。这些信息允许输出插件轻松地识别规则。此选项应与rev关键字一起使用。<br>文件sid-msg.map包含警报消息到Snort规则ID的映射。在对警报进行后处理以将ID映射到警报消息时，此信息非常有用。<br><code>sid:&lt;snort rules id&gt;;</code></p>
<h4 id="rev"><a href="#rev" class="headerlink" title="&#x3D;&#x3D;rev&#x3D;&#x3D;*"></a><em>&#x3D;&#x3D;rev&#x3D;&#x3D;</em>*</h4><p>rev关键字用于唯一标识Snort规则的修订。修订版本与 Snort 规则 ID 一起允许改进签名和描述并将其替换为更新的信息。<br><code>rev:&lt;revision integer&gt;;</code><br>示例：此示例是Snort规则修订版为1的规则。<br><code>alert tcp any any -&gt; any 80 (content:&quot;BOB&quot;; sid:1000983; rev:1;)</code></p>
<h4 id="classtype"><a href="#classtype" class="headerlink" title="&#x3D;&#x3D;classtype&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;classtype&#x3D;&#x3D;</strong></h4><p>classtype关键字用于将规则分类为检测属于更一般类型的攻击类的攻击。Snort提供了一组默认的攻击类，由它提供的默认规则集使用。为规则定义分类提供了一种更好地组织Snort生成的事件数据的方法。<br><code>classtype:&lt;class name&gt;;</code><br>例如：<br><code>alert tcp any any -&gt; any 25 (msg:&quot;SMTP expn root&quot;; flags:A+; content:&quot;expn root&quot;; nocase; classtype:attempted-recon;)</code><br>Snort定义的攻击分类位于classification.config文件中。该文件使用以下语法：<br><code>config classification:  &lt;class name&gt;,&lt;class description&gt;,&lt;default priority&gt;</code><br><em>classtype 选项只能使用已通过配置分类选项在snort.conf中定义的分类。Snort 在分类.config 中提供了一组默认分类 ，供其提供的规则使用。</em></p>
<h4 id="priority"><a href="#priority" class="headerlink" title="&#x3D;&#x3D;priority&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;priority&#x3D;&#x3D;</strong></h4><p>priority标记为规则分配严重性级别。classtype规则分配默认优先级（由配置分类选项定义），该优先级可以被优先级规则覆盖。每种情况的例子如下。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert tcp any any -&gt; any 80 (msg:&quot;WEB-MISC phf attempt&quot;; flags:A+;content:&quot;/cgi-bin/phf&quot;; priority:10;)  </span><br><span class="line">  </span><br><span class="line">    alert tcp any any -&gt; any 80 (msg:&quot;EXPLOIT ntpdx overflow&quot;;dsize:&gt;128; classtype:attempted-admin; priority:10;)</span><br></pre></td></tr></table></figure></div>
<h4 id="metadata"><a href="#metadata" class="headerlink" title="&#x3D;&#x3D;metadata&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;metadata&#x3D;&#x3D;</strong></h4><p>metadata标记允许规则编写者嵌入有关规则的附加信息，通常采用键-值格式。某些元数据键和值对Snort有意义，并在表中列出。除了表中列出的键之外，Snort实际上会忽略这些键，并且这些键可以是自由格式的，只有一个键和一个值。多个键之间用逗号分隔，而键和值之间用空格分隔。<br>![[3.2 snort-metadata.png]]</p>
<h3 id="2）有效负荷检测规则选项"><a href="#2）有效负荷检测规则选项" class="headerlink" title="2）有效负荷检测规则选项"></a>2）有效负荷检测规则选项</h3><h4 id="content"><a href="#content" class="headerlink" title="&#x3D;&#x3D;content&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;content&#x3D;&#x3D;</strong></h4><p>content关键字是Snort的重要特性之一。它允许用户设置规则，搜索数据包有效载荷中的特定内容，并根据该数据触发响应。如果数据包的有效负载中包含与参数数据字符串完全匹配的数据，则测试成功，并执行其余的规则选项测试。请注意，此测试是区分大小写的。<br>content关键字的选项数据有些复杂;它可以包含混合的文本和二进制数据。二进制数据通常包含在<code>|</code>字符中，并表示为字节码。字节码将二进制数据表示为十六进制数，是描述复杂二进制数据的一种很好的速记方法。下面的示例显示了在Snort规则中混合使用文本和二进制数据。<br><strong>可以在一个规则中指定多个内容规则。这允许规则被定制以减少误报。</strong><br>如果规则前面有a！，将在不包含此内容的数据包上触发警报。这在编写要对不匹配特定模式的数据包发出警报的规则时很有用。<br><code>alert tcp any any -&gt; any 139 (content:&quot;|5c 00|P|00|I|00|P|00|E|00 5c|&quot;;)</code><br><code> alert tcp any any -&gt; any 80 (content:!&quot;GET&quot;;)</code></p>
<h4 id="protected-content"><a href="#protected-content" class="headerlink" title="&#x3D;&#x3D;protected_content&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;protected_content&#x3D;&#x3D;</strong></h4><p><code>protected_content</code>关键字提供了<code>content</code>关键字的大部分功能，但是它的执行和使用方式非常不同。<code>protected_content</code>相对于<code>content</code>的主要优势是protected允许人们通过仅显示目标内容的安全哈希摘要来隐藏所述内容。与content关键字一样，它的主要目的是匹配特定字节的字符串。<br>目前，可以使用MD5、SHA256和SHA512哈希算法与protected_content关键字。如果在Snort配置中未设置默认值，则必须在规则中使用 hash 指定哈希算法。此外，使用protected，必须指定 length 修饰符，以指示原始数据的长度。<br>与<code>content</code>一样，可以在一个规则中使用多个<code>protected_content</code>规则。此外，可以将多个<code>protected_content</code>规则与多个<code>content</code>规则混合使用。<br><strong>如果规则前面有a！，将在不包含目标内容的分组上触发警报。这在编写要对不匹配特定模式的数据包发出警报的规则时很有用。</strong><br>格式：<code>protected_content:[!]&quot;&lt;content hash&gt;&quot;, length:orig_len[, hash:md5|sha256|sha512];</code><br>示例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert tcp any any &lt;&gt; any 80 (msg:&quot;MD5 Alert&quot;;protected_content:&quot;293C9EA246FF9985DC6F62A650F78986&quot;; hash:md5; offset:0; length:4;)</span><br><span class="line"></span><br><span class="line">alert tcp any any &lt;&gt; any 80 (msg:&quot;SHA256 Alert&quot;; protected_content:&quot;56D6F32151AD8474F40D7B939C2161EE2BBF10023F4AF1DBB3E13260EBDC6342&quot;;hash:sha256; offset:0; length:4;)</span><br></pre></td></tr></table></figure></div>
<h4 id="hash"><a href="#hash" class="headerlink" title="&#x3D;&#x3D;hash&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;hash&#x3D;&#x3D;</strong></h4><p>hash关键字用于指定匹配protected_content规则时使用的哈希算法。如果Snort配置中未指定默认算法，则protected_content规则必须指定所使用的算法。目前支持MD5、SHA256和SHA512。<br>格式：<code> hash:[md5|sha256|sha512]</code></p>
<h4 id="length"><a href="#length" class="headerlink" title="&#x3D;&#x3D;length&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;length&#x3D;&#x3D;</strong></h4><p>length关键字用于指定protected_content规则摘要中指定的内容的原始长度。提供的值必须大于0且小于65536。<br>格式：<code>length:[&lt;original_length&gt;];</code></p>
<h4 id="nocase"><a href="#nocase" class="headerlink" title="&#x3D;&#x3D;nocase&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;nocase&#x3D;&#x3D;</strong></h4><p>指定对content字符串大小写不敏感。</p>
<h4 id="rawbytes"><a href="#rawbytes" class="headerlink" title="&#x3D;&#x3D;rawbytes&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;rawbytes&#x3D;&#x3D;</strong></h4><p>rawbytes关键字允许规则查看原始数据包数据，忽略预处理器完成的任何解码。<br>HTTP Inspect有一组关键字来使用原始数据，例如http_raw_cookie，http_raw_header，http_raw_uri等，它们与原始HTTP请求和响应的特定部分相匹配。如果rawbytes没有明确指定，大多数其他预处理器默认使用解码&#x2F;规范化数据进行内容匹配。因此，应该指定rawbytes，以便检查数据包中的任意原始数据。<br><code>alert tcp any any -&gt; any 21 (msg:&quot;Telnet NOP&quot;; content:&quot;|FF F1|&quot;; rawbytes;)</code><br>这个例子告诉内容模式匹配器查看原始流量，而不是由HTTP解码器提供的解码流量。</p>
<h4 id="depth"><a href="#depth" class="headerlink" title="&#x3D;&#x3D;## depth&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;## depth&#x3D;&#x3D;</strong></h4><p>depth关键字允许规则编写者指定Snort应该在数据包中搜索指定模式的范围。<br>深度为5将告诉Snort只在有效负载的前5个字节内查找指定的payload。由于深度关键字是先前内容关键字的修饰符，因此在指定深度之前规则中必须有内容。<br>此关键字允许值大于或等于正在搜索的模式长度。允许的最小值为1。此关键字允许的最大值为65535。</p>
<h4 id="offset"><a href="#offset" class="headerlink" title="&#x3D;&#x3D;offset&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;offset&#x3D;&#x3D;</strong></h4><p>offset关键字允许规则编写者指定从何处开始搜索数据包中的模式。<br>偏移量5将告诉Snort在payload的前5个字节之后开始查找指定的模式。<br>由于此关键字是前一个内容关键字的修饰符，因此在指定偏移量之前，规则中必须有内容。此关键字允许的值范围为-65535到65535。</p>
<h4 id="distance"><a href="#distance" class="headerlink" title="&#x3D;&#x3D;distance&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;distance&#x3D;&#x3D;</strong></h4><p>distance关键字允许规则编写器指定Snort在开始搜索指定payload之前，应该忽略数据包中相对于前一个payload匹配结束的距离。<br>这可以被认为是与offset完全相同的东西，只不过它是相对于最后一个payload匹配的末尾而不是数据包的开头。<br>例子：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert tcp any any -&gt; any any (content:&quot;ABC&quot;;content:&quot;DEF&quot;; distance:1;)</span><br></pre></td></tr></table></figure></div>
<p>上面说的可能难理解，这个规则可以匹配：&#x2F;ABC.{1,}DEF&#x2F;. 一下就知道了哈哈哈。<br>后面的规则字段还有很多，这里只是列举出来了常用的。完整版在这里：<a class="link"   href="http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node32.html" >http://manual-snort-org.s3-website-us-east-1.amazonaws.com/node32.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="四-编写规则，运行Snort"><a href="#四-编写规则，运行Snort" class="headerlink" title="四.编写规则，运行Snort"></a>四.编写规则，运行Snort</h1><p>我们在<code>Snort/etc/</code>文件夹下面可以看到一个配置文件：<code>snort.conf</code>，在这个文件中，指定了规则文件存放路径：<br><code>var RULE_PATH ../rules</code><br>..&#x2F;rules就是说在Snort&#x2F;rules文件夹中，我们到这个文件夹中看一下，有没有这个目录，如果没有的话，自己创建出来。<br>然后，在该文件夹下编写我们自己的规则，然后将规则文件名添加到<br>![[4.1 rules_path.png]]<br>这里的这些应该都是自带的，或者说我们可以从官网中一次性全下载到，但是我这里没有，所以我将这里的所有include的规则文件都删除，然后将我自己的规则文件添加上去：<br>![[4.2 test.rules.png]]<br>到这里，我们就完成了Snort最基本的配置，至于高级用法，后续慢慢学习到之后会更新。<br>最后，使用我们之前学习到的命令，将Snort启动即可。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Snort</tag>
      </tags>
  </entry>
</search>
